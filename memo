オブジェクトとは「もの」のことをいう

1は整数オブジェクト
5.0は少数オブジェクト
"カフェラテ"は文字列オブジェクト

putsはオブジェクトではなく、メソッド（命令）

オブジェクトの種類のことをクラスという

整数オブジェクトはInteger(整数)オブジェクトと呼ぶこともあるし、Integerがクラスの名前になる
小数オブジェクトはFloatオブジェクトとも呼び、Floatがクラスの名前



変数はオブジェクトにつける名札のこと
・変数への代入
変数 = オブジェクト


文字列に計算結果を埋め込む
#{計算式}と書くことで、文字列に計算結果を埋め込んで表示することができる
これを式展開といい、計算式を文字列に展開するという意味


変数の名前のルール
変数の名前には原則として、英字、数字、_(アンダースコア)を使う
先頭は英字小文字または_(アンダースコア)で始める

英字はすべて小文字で書き2単語以上を繋げるときに_を間に入れる
例）my_order, my_favorite_order


定数
先頭が大文字の名前を付けると、定数になる。2文字目以降は小文字も大文字もつかうことができる



末尾に？が付くメソッド
末尾に？が付くメソッドはtrueやfalseのどちらかを返す
<や==などの比較メソッドと同じように使うことができる


「aまたはb」は a || b と書く
どちらか一方でも満たせば条件を満たす

「aかつb」は a && b と書く
両方を満たせば条件を満たす



caseは「1つの変数の値に応じて、複数の処理から1つを選んで実行する」ときに便利な書き方
ifでも同じ処理はかけるが、caseの方がスッキリ書ける
ifは2つに分岐、caseは3つ以上に分岐と考える



決まった数だけ繰り返す
timesメソッド

重複を避けてプログラムを書く習慣をDRYと言う


配列とは
配列はオブジェクトをまとめて扱う部品

数値や文字列と同じように、配列自身もオブジェクト
オブジェクトの種類のことをクラスという
配列のクラス名はArray   Arrayは配列という意味の英単語
配列のことを、配列オブジェクト、Arrayオブジェクト、そのまま配列と呼ぶ


配列は[で始まり]で終わる。[と]の間にカンマ区切りで複数のオブジェクトをかくことができる


変数に代入して配列に名前をつける
他のオブジェクトのときと同じく、配列オブジェクトに名札を付けるイメージ


配列の要素を取得する
変数の後ろに[n]をつけることで、配列のn番目の要素を取得できる
番号は0から始まる

配列の要素を取得するときは、後ろから数えることもできる
後ろから数えるときは、マイナスの数を使う
一番後ろの要素が-1番目、その前が-2番目


nilは「何もない」ことを表すオブジェクト
配列に対して、対応する要素がない場所から取得するとnilオブジェクトが返る


要素を追加する
配列へ要素を追加する
配列の末尾へ追加するにはpushメソッド、先頭へ追加するにはunshiftメソッドを使う


要素を削除する
配列の末尾から要素を1つ削除するにはpopメソッド、先頭から要素を1つ削除するにはshiftメソッドを使う


配列を足し算する
配列は足し算することができる
足し算すると、2つの配列をつなげた新しい配列をつくる


配列の引き算
配列は引き算することができる
引き算すると、元の配列から要素を取り除いた新しい配列をつくる

引き算を使うと「配列aと配列bを比べて、配列aにだけある要素」を得ることができる。


配列.unshift(追加するオブジェクト)ーー配列の先頭へ追加
配列.push(追加するオブジェクト)ーー配列の末尾へ追加
配列.shiftーー配列の先頭から削除
配列.popーー配列の末尾から削除
配列 + 配列ーー2つの配列の要素をつなげた配列をつくる
配列 - 配列ーー後ろの配列の要素を除いた配列をつくる


配列を繰り返し処理する
配列を繰り返し表示する
配列オブジェクトの全要素を表示する
eachメソッドは、配列の全要素を繰り返し処理する
doからendはブロックと呼ばれる部品


繰り返しを途中で終わらせる
breakを使うと繰り返し処理を途中で終わらせることができる


繰り返しの次の回へ進む
nextを使うと、繰り返しのその回をそこで終わりにして、次の回へ進む


範囲を指定して繰り返す
「３から５までの数を１ずつ増やして繰り返したい」ときは範囲を表すオブジェクトを使う Rangeオブジェクトと呼ばれる
Rangeオブジェクトにeachメソッドを呼び出すと、ブロックの中の変数にその範囲の数値を代入して繰り返す


配列の要素数を得る
配列の要素数を得るときはsizeメソッドを使う
sizeメソッドは配列の要素数を返すメソッド
sizeメソッドは呼び出されると、配列の要素数を返す。メソッドの実行結果として返ってくる値のことを「戻り値」という


配列の全要素の合計を得る
配列の全要素の合計はsumメソッドで計算できる


sizeメソッドとsumメソッドを組み合わせると平均値の計算ができる
平均値は「全要素の合計 / 要素数」で計算できる


少数が出てくる計算
小数点以下を計算したい場合はどちらか（または両方に）to_fメソッドで小数オブジェクトに変換する


メソッドの名前から機能を調べる
リファレンスマニュアルで調べることができる

uniqメソッド
uniqは配列から重複した要素を取り除いた新しい配列を返す

uniq!は削除を破壊的に行い、削除が行われた場合はselfを、そうでなければnilを返す


要素に！がつくメソッド
uniqに対するuniq!のように、メソッド名の末尾に記号!が付くメソッドが用意されていることがある。

uniq!メソッドは、自分自身の配列オブジェクトを変更する。
このような変化のことを「破壊的変更」と言う


るりまサーチ
メソッド名が分かっていて、その働きを調べたいときは「るりまサーチ」を使う方法もある


ランダムに要素を取得する
sampleメソッド

a = (1..10).to_a
p a.sample #=> 9   ランダムで数字か返ってくる
p a.sample(3) #=> [1, 9, 3]


ランダムに並び替える
shuffleメソッド
sampleメソッドはランダムで1要素を取得する機能だったが、ランダムに並び返ることができるshffleメソッドもある
shffleメソッドは配列の要素をランダムに並び換えるメソッド

配列の要素を並び換える
配列の要素を順に並び換える時はsortメソッドを使う
sortメソッドは要素を順に並べるメソッド
配列の要素が数値の時は、小さい順に並び換える
配列の要素が文字列の時はabc順に並び換える
先頭の文字で比較して、同じであれば2文字目
先頭の文字が大文字と小文字が混じると「大文字が先、小文字が後」になる



配列の要素を逆順にする
配列の要素を逆順にするにはreverseメソッドを使う

逆順にするには
1、sortメソッドで小さい順に並び換え
2、reverseメソッドで逆順にする


配列中の文字列を連結する
joinメソッドは、配列中の文字列を連結するメソッド

文字列を分割して配列にする
スペースが区切り文字として入っている文字列をスペースのところで区切って配列にするプログラム
splitメソッドは文字列を区切り文字で分割して配列するメソッド



joinメソッドを使うと、配列の全要素をつなげた文字列が作られる
joinメソッドへ文字列を渡すと、要素間に挟んでつなげた文字列を作られる
splitメソッドを使うと、文字列をスペースで区切って要素とした配列が作られる
splitメソッドへ文字列を渡すと、区切り文字として使われる


配列の各要素を変換した配列を作る
mapメソッドは配列の各要素へ処理を行い、変換してできた要素を持った、新しい配列を作るメソッド

mapメソッドはブロックを渡して各要素について処理を行う点が、eachメソッドと似ている
eachメソッドは各要素についてブロックで処理を行うことが目的となり、mapメソッドは各要素を変換した新しい配列を得ることが目的となる


配列.map do |変数|
  変換処理
end

mapメソッドは、配列の全要素にブロック中の処理で変換を行った、新しい配列を作る


ハッシュとは
ハッシュは複数のオブジェクトをまとめることができる入れ物
複数のデータを扱えることは配列と同じだけど、ハッシュは「キー」と「値」のセットで複数のデータを扱うことができる

ハッシュは{で始まり、}で終わる。{と}の間にカンマ区切りでキーと値の組みをいくつでもかくことができる
記号=>の前に「キー」となるオブジェクトを置き、後に「値」となるオブジェクトを書く

記号=>は見た目がロケットぽいので、親しみをこめてハッシュロケットと呼ばれている

配列と同じように、ハッシュもオブジェクト
ハッシュのことをハッシュオブジェクト、またはHashオブジェクトあるいはハッシュと呼ぶ


シンボルとは
キーの部分に書かれた:coffeeと:caffe_latteは、シンボルと呼ばれるオブジェクト
シンボルは文字列と似ているオブジェクト
文字列は"coffee"のようにダブルクォーテーションで囲みますが、シンボルはコロンから始める

シンボルのクラス名はSymbol
シンボルはハッシュのキーでラベルのように使われる

シンボルは文字列と相互に変換することができる
文字列からシンボルへはto_symメソッドを、シンボルから文字列へはto_sメソッドを使う


ハッシュには2つの書き方がある
①{:coffee => 300, :caffe_latte => 400}
②{coffee: 300, caffe_latte: 400}


①の方が主流で書きやすい


変数に代入してハッシュに名前を付ける
変数に代入してハッシュに名前を付ける
他のオブジェクトのときと同じく、ハッシュオブジェクトに名札を付けるイメージです。


ハッシュから値を取得する
ハッシュから値を取得する方法

キーはcoffeeではなく、:coffeeと書く
キーはシンボルなので、先頭にコロンがつく

ハッシュのキーの部分にはシンボルを使うことが多いのに対して、値の部分にはさまざまなオブジェクトを置く
文字列や整数だけでなく、配列や別のハッシュを置くこともできる

{title: "Ruby Book", members: ["yano", "beco"]}


ハッシュの書き方
キーがシンボルのときの書き方
{キー: 値, キー: 値}

キーがシンボル以外でも使える書き方
{キー => 値, キー => 値}

ハッシュのキーから値を取得
ハッシュ[キー]

ハッシュ(Hash)オブジェクトは複数のオブジェクトをきーと値の組みでまとめて扱うもの
ハッシュは{で始まり}で終わり、カンマ区切りでキーと値の組みを複数書くことができる
キーにはシンボルが使われることが多い
{}は空のハッシュ
ハッシュはキーから値を取得できる


ハッシュへキーと値の組を追加する
追加したキーと値の組は末尾に追加される
ハッシュも配列と同じように順番に並んでいますが、ハッシュではキーを指定して値を取得する使い方が多いため、順番を意識することはあまりない


ハッシュは同じキーを複数モテない
ハッシュにすでにあるキーで値を追加しようとすると、後から追加したもので上書きされる
ハッシュは同じキーを複数持つことはできない


存在しないキーを指定したとき
ハッシュから存在しないキーを指定して値を取得しようとするとnilが得られる



2つのハッシュを1つにまとめる
2つのハッシュを1つにまとめるときはmergeメソッドを使う
merageメソッドは元のハッシュと、指定したハッシュを1つにまとめて新しいハッシュを作るメソッド


ハッシュからキーと値の組を削除する
ハッシュからキーの値の組を削除するときはdeleteメソッドを使う。
ハッシュ.delete(キー)と書くと指定したキーと値の組を削除する


ハッシュを繰り返し処理する
ハッシュの繰り返し処理

ハッシュ.each do |キーの変数,値の変数|
  繰り返し実行する処理
end


eachメソッドとブロックを使うとハッシュの全要素を繰り返し処理できる
キーと値がそれぞれ変数に代入されて、繰り返し処理が実行される


メソッドとは
メソッドは名前をつけた「処理の部品」
putsやpは「画面に表示する処理」の部品、sumは「合計値を計算する処理」の部品、といった具合
名前をつけて部品にしておくことはメリットがある
ある処理を書く時に1からすべてのプログラムをかくのではなく、既に用意されている名付けられた処理の部品、
つまりメソッドを使うことで、プログラムを簡単に書くことができる。


メソッドを定義する
自分でもメソッドを定義することができる
メソッドを定義することをメソッドを定義するという

メソッドを実行することをメソッドを呼び出すという

定義したメソッドは、メソッド名を書くことで呼び出すことができる


メソッドの戻り値とは
メソッドにはオブジェクトを呼び出し元へ返す「戻り値」の仕組みがある。
配列のsumメソッドやsizeメソッドで結果を取得するのにつかったのは戻り値の仕組み

メソッドは最後の実行結果が戻り値として呼び出し元へ返る仕組み


戻り値は変数に代入することもできる

メソッド定義
def メソッド名
  処理
end

メソッド呼び出し
メソッド名

メソッドは「処理の部品」に名前をつけたもの
メソッド定義（作成）はdefを使う
メソッド定義しただけでは中の処理は実行されない
定義したメソッドは呼び出すことで実行される
メソッドオブジェクトを呼び出し元に返す戻り値の仕組みがある
メソッドで最後に実行した結果が戻り値になる



引数を使ってオブジェクトを渡せるメソッドを定義する
メソッドには引数というオブジェクトを渡す機能が用意されている


2つ以上の引数を持つメソッドを定義する
引数は３つ以上にすることもできる。原則として、引数の個数はメソッドの定義側と呼び出し元で同数にする必要がある

メソッドを途中で終わらせる -return
returnを書くことでメソッドの処理が終わり、呼び出しへ戻る
returnより後に書いた行は実行されない


引数を持つメソッドの定義
def メソッド名（引数1, 引数2, ...）
  処理
end

引数を渡すメソッド呼び出し
メソッド名（引数1, 引数2, ...）

メソッド定義で引数設定すると、呼び出し元からメソッドへオブジェクトを渡すことができる
returnを実行すると、そこでメソッドの処理を終えることができる
returnが実行されたときは、returnに続いて書いたオブジェクトが戻り値となる

引数の便利な機能
引数を省略した時のデフォルト値

メソッドの引数には、デフォルト値を指定することができる
デフォルト値とは、引数を省略してメソッドが呼び出された時に使われる値
デフォルト値を指定するには、メソッド定義で引数=デフォルト値と書く

デフォルト値を指定して引数を省略して呼び出すとデフォルト値が返される
引数を指定した場合はデフォルト値は使われない


引数の順番を変えられるキーワード引数
メソッド定義で引数名の後ろに:をつけると、キーワード引数になる
キーワード引数を使うとメソッドを呼び出す時に引数を名前（キーワード）付きで指定できる。
呼び出しの書き方を覚えるときは、{}を省略したハッシュと同じと考える
キーワード引数は、引数の順序を変えても呼び出せるという大きなメリットがある


キーワード引数でのデフォルト値
キーワード引数でもデフォルト値を使うことができる


メソッド定義 デフォルト値あり
def メソッド名（引数1 = デフォルト値１, 引数2 = デフォルト値2, ...）
  処理
end

メソッド定義キーワード引数
def メソッド名（引数1:, 引数2:, ...）
  処理
end

メソッド定義キーワード引数デフォルト値あり
def メソッド名（引数1: デフォルト値1, 引数2: デフォルト値2, ...）
  処理
end

メソッド呼び出し キーワード引数
メソッド名（引数1: オブジェクト1, 引数2: オブジェクト2, ...）


変数には見える範囲がある

ローカル変数とスコープ
メソッドを使うと、処理のかたまりを独立させることができる

変数には見える範囲と寿命がある。
変数の見える範囲と寿命のことを「スコープ」という

メソッドの外に書いてある変数も、メソッドの中ではみることができない
メソッドの中で必要なオブジェクトは、引数を使って渡す


変数にはスコープ（見える範囲と寿命）がある
ローカル変数は定義したメソッドの中がスコープになり、メソッドの外では見えない
同様に、メソッドの外で定義したローカル変数は、メソッドの中では見えない



クラスとは
オブジェクトはクラスに属している
1, 2, 100   整数オブジェクト  Integer
"カフェラテ", "hello"  文字列オブジェクト  String
[1,2,3],["コーヒー","カフェラテ"]  配列オブジェクト  Array


オブジェクトは異なる特徴を持っているが、すべてのオブジェクトがばらばらというわけではない
クラスとは「オブジェクトの種族を表すもの」
すべてのオブジェクトは、いずれかのクラスに属している。どのクラスに属しているかはclassメソッドで調べることができる

クラスに属するオブジェクトをそのクラスの「インスタンス」であるともいう
インスタンスはオブジェクトとほぼ同じ意味で使うが、
「クラスから作ったオブジェクトである」「そのクラスに属する」ということを強調したい時に使う

オブジェクトは、所属するクラスが用意しているメソッドを使うことができる
Integerクラスのオブジェクトたちには、整数を扱うときに便利なメソッドがいろいろ用意されている

Stringクラスに属するオブジェクトで、Integerクラスには属していない。
なので、Integerクラスで用意されているeven?メソッドを使おうとしてもエラーになる


オブジェクトを作る2つの方法
オブジェクト作成
クラス.new

クラスのnewメソッドを呼び出すことで、そのクラスのオブジェクト（インスタンス）を作ることができる。

String.newを実行すると、空であるStringクラスのオブジェクト、つまり空文字列を作る。
String.new("カフェラテ")のようにnewメソッドの引数に文字列を渡すと、その文字列であるオブジェクトを作る。

Array.newを実行すると、空であるArrayクラスのオブジェクト、つまり空配列を作る
Arrayのnewメソッドへ引数に個数（2）と要素にするオブジェクト（"カフェラテ"）を渡すと、
そのオブジェクトを指定した個数だけ持った配列オブジェクトを作る


そのオブジェクトの属するクラスを表示する
オブジェクト.class

そのクラスのオブジェクトを作成する
クラス.new


クラスはオブジェクトの種族を表すもの
すべてのオブジェクトは、いずれかのクラスに属す
オブジェクトがどのクラスに属しているかは、classメソッドで調べることができる
クラスに属するオブジェクトを、そのクラスの「インスタンス」であるともいう
newメソッドを使うと、そのクラスのオブジェクト（インスタンス）を作ることができる


クラスを作る
Rubyにはたくさんのクラスが用意されている。Integer（整数）クラスやFloat（少数）クラスは計算の場面で、
String（文字列）クラスは単語や文章を扱う場面で、Array（配列）クラスやHash（ハッシュ）クラスは複数の
オブジェクトを一緒に扱う場面で使うことができる。


クラスは自分で作ることもできる。
自分でクラスを書き、そのクラスのオブジェクトを作り、使うことでプログラムを整理して書くことができる。
クラスを使ってプログラムをかくと、大規模なプログラムを設計してかくことができるようになる。

クラスを作ることをクラスを定義するという

クラスの定義
class クラス名
end

クラスは定義するだけでは何も目に見える処理をしないので、実行しても何も表示されない。

クラスはnewメソッドを使うことでそのクラスのオブジェクトを作ることができる。
クラスはその種類のオブジェクトを作ることができる工場のようなもの
そのクラス自身が仕事をすることもあれば、そのクラスから作ったオブジェクトが仕事をすることもある

新しいクラスを作ることで、新しい特徴を持ったキャラクター（プログラムの世界ではオブジェクト）を作ることができる


クラス名の規則
クラス名は、Drink,Itemのように先頭を大文字で始める。習慣として、2文字目以降は小文字にして、2単語以上を組み合わせた名前にする場合は
CaffeLatteのように区切り文字を大文字にしてつなぐ。
このようなスタイルをキャメルケースと言う。

クラスの名前も定数
クラスを定義すると、クラス名の定数が作られる。
クラスも実はオブジェクト

クラスを定義する
class クラス名
end

そのクラスのオブジェクトを作る
クラス.new

クラス名は先頭を大文字で始める
クラス名を2単語以上つなげた名前にするときはCaffeLatteのように区切り文字を大文字にしてつなぐ（キャメルケース）


オブジェクトが呼び出せるメソッドを作る
クラスにメソッドを定義する
自分で定義したクラスには、最初はnewメソッドでオブジェクトを作るなど、最低限の機能しかない。
欲しい機能を持ったクラスを育てていくことができる。

クラスでのメソッド定義
class クラス名
  def メソッド名
  end
end


クラスに定義したメソッドを呼び出す
メソッドを呼び出すには、オブジェクトに対して、.メソッドと書く。
オブジェクトが変数に代入されているときは、今回のdrink.nameのように、変数.メソッドと書く

クラスに定義したメソッドは、そのクラスに属するすべてのオブジェクトで呼び出すことができる。
クラスにメソッドを定義しておけば、そのクラスからオブジェクトを作って、そのオブジェクトたち全員でそのメソッドを呼ぶことができる。


レシーバ
「メソッドが呼び出されるオブジェクト」のことを「レシーバ」と呼ぶ。

methodsメソッドを使うと、レシーバであるオブジェクトで呼び出せるメソッド一覧表示することができる

クラスに引数を受け取るメソッドを定義する
クラスに定義するメソッドにも引数でオブジェクトを渡すことができる


クラスの中で同じクラスのメソッドを呼び出す
クラスに複数のメソッドを定義することもできる
クラスに定義されたメソッドの中で同じクラスのほかのメソッドを呼ぶときは、メソッド名をそのまま書くことでよびだせる
クラス定義の外側でメソッドを呼び出すときは、このようにレシーバとなるオブジェクトに対してメソッドを呼び出す


selfを使ってレシーバを調べる
レシーバが何か分からないときには、selfを使うと調べることができる
selfは、その場所でメソッドを呼び出したときのレシーバを返す


クラスにメソッドを定義する
class クラス名
  def メソッド名
  end
end

メソッドを呼び出す
オブジェクト.メソッド

クラスにメソッドを定義するときは、classクラス名からendの間にdefメソッドを書く

クラスのメソッドを呼び出すときは、そのクラスのオブジェクトへ続けて、.メソッド名と書く

メソッドが呼び出されるオブジェクトを「レシーバ」と呼ぶ

クラスの中でメソッドを呼び出すときはレシーバを省略してメソッド名だけで呼び出せる


オブジェクトにデータを持たせる
インスタンス変数
インスタンス変数はその名の通り、インスタンス（オブジェクト）が持つ変数。
ローカル変数と違って、同じオブジェクトであれば、複数のメソッドをまたいで使うことができる。
寿命もオブジェクトと同じになり、オブジェクトが存在する間はずっとインスタンス変数を使うことができる
インスタンス変数は、変数名の先頭に＠をつけることで作ることができる。


インスタンス変数はオブジェクトごとに存在する
インスタンス変数は、インスタンス、つまりオブジェクトごとに存在する変数。
同じクラスに書かれているインスタンス変数でも、オブジェクトが別ならば、別のインスタンス変数になる。


インスタンス変数を取得するメソッドを作る

インスタンス変数へ代入するメソッドを作る
インスタンス変数を取得するメソッドが作れたので、インスタンス変数へ代入するメソッドも作る
インスタンス変数へ代入するメソッドは、習慣的に「インスタンス変数名から@を取り、末尾に=を加えたもの」にすることが多い
今回のメソッド名も、インスタンス変数@nameへ代入するので、そこから@を取り除き末尾に=を加えたname=にしている


instance_variablesメソッド
オブジェクトに対してinstance_bariablesメソッドを呼び出すと、持っている全てのインスタンス変数を返す
instance_bariablesメソッドは、オブジェクトが持っているインスタンス変数の変数名一覧を取得するメソッド


名前が@ではじまる変数はインスタンス変数
インスタンス変数はローカル変数よりもスコープが広く、同じオブジェクトであればメソッドをまたいで使うことができる
インスタンス変数はオブジェクトごとに持っている
インスタンス変数は代入が実行されたときに生まれる
インスタンス変数の寿命はオブジェクトの寿命と同じになる
メソッド名の末尾が=で終わるメソッドはdrink.name = "カフェラテ"
のように = を離して書くことができる




オブジェクトが作られるときに処理を行う
initializeメソッド
クラスにはinitializeという特別なメソッドが用意されている
initializeという名前のメソッドを作ると、オブジェクトが新しく作られるときに自動で呼び出される


インスタンス変数の初期値を設定する
initializeメソッドが便利な場面の例として「インスタンス変数の初期値を設定する」がある

initializeメソッドへ引数を渡す
初期値を自由に設定するにはinitialieメソッドに引数をわたせるようにすることで解決できる
initializeメソッドに引数を受け取るように定義して、newメソッドを呼び出すときにオブジェクトを渡すと、
initializeメソッドで引数として受け取ることができる


initializeメソッドを定義しておくとオブジェクトが作られるときに自動で呼び出されて実行される
initializeメソッドに引数を受け取るように定義しておくと、newメソッドを呼び出すときに渡すことで、
initializeメソッドで引数として受け取ることができる



クラスを使ってメソッドを呼び出す
インスタンスメソッドとクラスメソッド
クラスに作るメソッドは2種類ある。
インスタンスをレシーバーとするメソッドとクラスをレシーバーとするメソッド

インスタンスメソッドの例
drink.name
[1, 2, 3].size
1.even?

クラスメソッドの例
Drink.new
Array.new


クラスメソッドを定義する
クラスメソッドの定義
def self.メソッド名
end

クラスメソッドを定義するには、defのメソッド名を書くところで、メソッド名の前にself.をつける
クラスメソッドを呼び出すときはCafe.welcomeのように、クラス名に続いて .メソッド名で呼び出すことができる。
クラスメソッドはクラスが実行するので。オブジェクトを作ることなく呼び出すことができる


同じクラスのクラスメソッドを呼び出す
クラスメソッドの中で同じクラスのクラスメソッドを呼ぶときは、インスタンスメソッドのときと同じように、メソッド名だけを書けばOK
レシーバを省略しない形で書くと、self.クラスメソッドまたはクラス.クラスメソッドとなる

インスタンスメソッドからクラスメソッドを呼ぶこともできる。self.class.クラスメソッド
またはクラス.クラスメソッドという書き方をする

クラスメソッドからインスタンスメソッドを呼び出すことはできない


インスタンスメソッドはインスタンスに対して呼び出すメソッド
クラスメソッドはクラスに対して呼び出すメソッド
クラスメソッドはdef self.メソッド名のようにメソッド名の前にself.を書いて定義する


継承を使ってクラスを分ける
継承
class クラス名 < スーパークラス名
end

Rubyが用意しているクラスの継承関係
あるクラスの継承関係をみるにはancestorsメソッドを使う
ancestorsメソッドは、そのクラスの継承関係（親クラス群）を表示するメソッド


親子のクラスで同名のメソッドを作ったときの動作
親子クラスで同名のメソッドがあるときは、自分のクラスのメソッドが呼ばれる
親クラスの同名メソッドは呼ばれず、多い隠された形になる

親クラスのメソッドを呼び出す
メソッドの中でsuperと書くことで、親クラスの同名メソッドを呼び出すことができる。


メソッドの呼び出しを制限する
クラスでのメソッド定義の中だけで呼び出せるメソッドをつくる


privateとpublic
最初にpublicなメソッドをまとめて書き、その後にprivateなメソッドをまとめてかくことが一般的


privateなクラスメソッドを定義する
self.メソッド名でクラスメソッドを定義できるが、この前にprivateを書いておいてもprivateなメソッドにならない

privateよりも後で定義したメソッドはprivateなメソッドになる
privateなメソッドはレシーバを指定したオブジェクト.メソッド名の形式で呼びだしができなくなる
クラスの中でprivateより前またはprivateを書かずに定義したメソッド、およびpublicよりも後ろで定義したメソッドはpublicなメソッドになる
publicなメソッドはオブジェクト.メソッド名の形式でも、レシーバを指定しない メソッド名の形式でも呼び出しができる





部品を共有利用する - モジュール
複数のクラスでメソッドを共同利用する

メソッドを共同利用する手順
複数のクラスでメソッドを共同利用するには、次の3つの手順を行う。
1. モジュールを作る
2. モジュールにメソッドを定義する
3. モジュールのメソッドをクラスで使う


モジュールを作る
モジュールの定義
module モジュール名
end

モジュールの定義はクラスの定義と似ている。モジュール名はクラス名と同じように、先頭を大文字から始めるキャメルケースで書く
書式もクラスと似ていてclassをmoduleに置き換えて書くことができる
モジュールはクラスと似ているものですが、クラスと違ってインスタンスを作ることができない


モジュールにメソッドを定義する
モジュールはクラスと同じようにインスタンスメソッドやクラスメソッド（正確にはモジュールメソッド）を定義できる
引数や戻り値も同じようにつかうことができる


モジュールのメソッドをクラスで使う - include
includeメソッド
class クラス名
  include モジュール名
end

クラスでincludeメソッドを使うと、引数で指定したモジュールのメソッドを、
あたかもクラス自身のインスタンスメソッドとして使えるようになる
1つのクラスの中でincludeメソッドは何度でも呼べるので、複数のモジュールを同じクラスでincludeしてそれらのメソッドを利用することもできる


モジュールは複数のクラスで共同利用できる
モジュールの優れたところは、複数のクラスで使えるところ。
複数のクラスでモジュールをincludeすることで、そのモジュールのメソッドを共同利用できる。

モジュールを使うとクラスの継承とは違った形でメソッドを共同利用する仕組みを提供することができる


モジュールのメソッドをクラスメソッドにする - extend
extendメソッドをクラスで使うと、モジュールのメソッドをextend先のクラスのクラスメソッドとして使うことができる
クラスでincludeを使うとモジュールのメソッドをインスタンスメソッドとして利用できるようになったが、extendを使うと
クラスメソッドとして利用できるようになる。


モジュールを定義する
module モジュール名
end

クラスにモジュールをインクルードする
class クラス名
  include モジュール名
end

モジュールを使うとメソッドを共同利用することができる
モジュールにはインスタンスメソッドを定義できる
モジュールはクラスと違い、インスタンスを作ることはできない
クラスにモジュールをインクルードすると、モジュールに定義したインスタンスメソッドを利用できる
eachメソッドを定義しているクラスで、Enumerableモジュールをインクルードするとメソッド群を利用できる
配列やハッシュではEnumerableモジュールのメソッド群を利用できる


モジュールのメソッドや定数をそのまま使う
モジュールにクラスメソッドを定義する
モジュールにはインクルードしてメソッドを提供する使い方のほかに、クラスメソッドや定数を定義して呼び出す使い方がある

モジュールWhippedCreamの中で定義されている定数Priceを使うときには、このようにWhippedCream::Priceと::でつなげて書く


Rubyが用意しているモジュールを使う
自分で定義するモジュールのほかにも、Rubyが用意している便利なモジュールを使う方法もある


名前空間
同じクラス名を複数の場所で使いたいが、別のクラスなので別々に定義して分けたい、というケース
モジュールを使って名前を分けるという手法がある
これを「名前空間を作る」とも言う


クラス名（またはモジュール名）の指定
クラス名（またはモジュール名）:: クラス名（またはモジュール名）

モジュールにはクラスメソッド、定数を定義できる
モジュールの中の定数を使うときは::でモジュール名と定数名をつなぐ


部品を別ファイルに分ける

別ファイルのクラスやモジュールを読み込む


includeとrequire_relativeの違い
includeとrequire_relativeはどちらも「読み込む」という機能で似ているように感じるが、違う機能
includeはモジュール名を渡して、そのモジュールに書かれたメソッドをクラスから利用できるようにするメソッド
require_relativeは、ファイル名を渡してそのファイルに定義されたクラスやモジュールを使えるようにするメソッド
セットで使うことも多い

ファイルを読み込む
require_relative "ファイル名"
require_relativeメソッドを使うと、別ファイルに定義されたクラスやモジュールを読み込んで使うことができる


Webアプリをつくる
ライブラリを使う
Gemのインストール
gem install Gem名


Bundlerとは
たくさんのgemをインストールしようとすると、使うGemの数だけコマンドを打たなくてはいけない
それは大変なので、複数のGemを簡単に管理するBundlerという仕組みが用意されている

BundlerでGem群をインストールするには2つの手順を踏む
Gemfileの作成、bundle installコマンドの実行


GemfileにインストールするGemを書く

bundle installコマンドでインストールする

bundle updateコマンドでGemをバージョンアップする

bundle execコマンドで指定したバージョンのGemを使う


Rubyでは、組み込みライブラリ、標準添付ライブラリ、Gemの3種類のライブラリがある
gem install Gem名でGemwoインストールできる
複数のGemwo簡単に管理するBundlerが提供されている
BundlerはGemfileという名のファイルに使うGem名を記述する
bundle installコマンドを実行するとGemfileに書かれたGemがインストールされ、Gemfile.lockができる
Gemfile.lockにはインストールされたGemとそのバージョンなどが書かれる
bundle updateコマンドを使うと利用中のGemの新しいバージョンがあればインストールされる
bundle execコマンドを使うとGemfileやGemfile.lockに書かれたGemバージョンでRubyのプログラムを実行する


簡単なWebアプリを作る
Webアプリとは
Webアプリとはブラウザから利用できるアプリのこと
HTMLとCSSに加えてRubyのプログラムを実行することで、状況に応じて表示を変えるWebページを作ることが可能になる


sinatra Gemを使ってWebアプリを作る

Webアプリの中でRubyプログラムを実行する

URLを理解する

Webアプリの基本動作
ブラウザがリクエストをサーバーへ投げる
Webアプリがリクエストに対応したレスポンスを返す
ブラウザがレスポンスで返ってきたHTMLを解釈して表示する

ブラウザがリクエストをサーバへ投げる
リクエストの主要な情報はURLとHTTP GETメソッドである

Webアプリがリクエストに対応したレスポンスを返す
レスポンスは「Webアプリが返す情報」と言える。ここでのレスポンスの主要な情報はHTML
ブラウザからアクセスされたときにはHTMLを返すことが多い


sinatra Gemを使うとWebアプリを簡単につくることができる
ブラウザはリクエストをサーバへ投げる
Webアプリはリクエストに対応したHTMLをつくり、レスポンスとして返す
ブラウザはレスポンスで返ってきたHTMLを解釈して表示する





Webへアクセスするプログラムを作る
URIとURL同じものと考えて問題ない


WebページへアクセスしてJSONを取得する
HTMLはブラウザで見ることが主目的であるため、HTMLデータの中から目当てのデータを取得する用途には向いていない
データをやりとりすることを目的とした別の形式としてJSONがある。


JSONへ変換
ハッシュからJSONへの変換も可能


WebページへHTTP POSTメソッドでリクエストをする

Net::HTTPクラスとURIモジュールを使うとHTTPリクエストを投げることができる
JSONモジュールを使うとJSONとハッシュとを変換できる


例外処理
例外とは
プログラムの実行時に、想定外の問題が起こることがある。
想定外の例外が発生するとRubyはエラーメッセージを表示してプログラムを停止させる

例外を処理する - rescue
例外は想定外の問題が起きた時に発生する。想定外の問題なのでRubyはエラーメッセージを表示してプログラムを停止させる
これは無理に処理を続けるよりは、その場でプログラムを止めた方が安全という考え方
例外を処理するためにはbigin~rescueを使う
rescue(レスキュー)は救助すると言う意味でまさに問題を対処するイメージ

例外処理
begin
  # 例外が発生する可能性がある処理
rescue 例外クラス
  # 例外が発生したときに実行する処理
end

rescue節は例外が発生したときのみ実行される
例外が発生しないとrescue節は実行されない


メソッド内で例外処理を書く場合は、beginとendを省略できる
メソッドの初めからrescueまでの処理で発生した例外を、rescue節で受け取れる


ブロック内でもbeginとendを省略できる


例外は「想定外の問題」が発生したときに使う。
今回のように入力値に0が入ることが想定できるときは、例外処理を使わずに事前に値をチェックする方がより良いプログラムになる


例外の詳しい情報を得る
発生した例外を画面に表示したり、ログファイルに記録したりするなど、例外の詳しい情報を取得したいことがある
Rubyでは例外もオブジェクト
例外オブジェクトを取得することで、例がの詳しい情報を取得できる。

例外オブジェクトの代入
begin
  # 例外が発生する可能性がある処理
rescue 例外クラス => e # 変数eに例外オブジェクトが代入される
  # 例外が発生したときに実行する処理（resce節）
end


例外を表すクラス
全ての例外はExceptionクラスを継承している
StandardErrorクラスは通常のプログラムでよく発生する例外を束ねるクラス
変数名やメソッドを間違えたときに発生するNameErrorやNoMethodErrorだけでなく、これまでのサンプルプログラムで使った
SystemCallErrorやZeroDivisionErrorもStandardErrorクラスのサブクラス


例外を発生させる - raiseメソッド
自分で例外を発生させることもできる
例外を発生させるときにはraiseメソッドを使う
引数には例外のメッセージを指定する。メッセージの部分は自由に書くことができる
どんな例外が起きたかをプログラマーが調べるときに使える。
例外クラスで例外の種類を指定し、メッセージに具体的なエラー内容を書くと良い

例外を発生させる
raise "例外メッセージ"

raise ScriptError, "致命的なエラーが発生しました"


例外の有無に関わらず必ず処理を実行する -ensure
例外処理にはもう1つ、ensureという機能がある。ensureからendの間に書いた内容は、例外の発生の有無に関わらず実行される

ensure
begin
  # 例外が発生する可能性のある処理
rescue => e
  # 例外が発生したときに実行する処理
ensure
  # 例外の発生有無に関わらず実行される処理
end


例外を使うことで正常な処理と例外処理を分けることができる
発生した例外はrescue節で受け取れる
raiseメソッドで例外を発生できる
例外の発生有無に関わらず実行したい処理はensure節に書く


クラスの高度な話
インスタンス変数を簡単に操作する

def name
  @name
end

attr_reader :name
と書き換えることができる

attr_readerは「同名のインスタンス変数を戻り値とするメソッドを定義する」メソッド
attr_readerの後ろに、インスタンス変数から@を取り除いた名前をシンボルで書く


def name=(text)
  @name = text
end

attr_writer :name
と書き換えることができる

attr_readerとattr_writerは今回のようにセットで使うことが多いため、この2つを合体させたattr_accessorメソッドが用意されている
attr_accessorメソッドは「同名のインスタンス変数を戻り値とするメソッドを定義する」と「同名のインスタンス変数へ代入するメソッドを定義する」
両方を行うメソッド


attr_reader :name
attr_writer :name

attr_accessor :name



self
何度か登場したselfについて。selfはその場所でのレシーバを返すもの。
レシーバとは、メソッドを呼び出されるオブジェクト

selfはその場所でメソッドを呼び出すときのレシーバのオブジェクトを返す
インスタンスメソッドでのselfは、そのクラスのインスタンスになる
クラスメソッドでのselfは、そのクラスになる
selfは変数のようにも見えるが、代入ができない


クラスメソッドとインスタンスメソッドでのインスタンス変数は別物

クラスメソッドとインスタンスメソッドでのインスタンス変数は別物


クラス変数
ローカル変数、インスタンス変数のほかに、クラス変数という変数もある。
これは、クラスで共有される変数。クラスが持つインスタンス変数と似ているが、継承したクラスでも共有する点が異なる。
クラス変数は@@nameのように、変数名を@2つで始める


文字列を調べる -正規表現
文字列を含むか判定する
文字列を/で囲んで正規表現オブジェクトをつくり、match?メソッドへ渡すと、その文字列を含むかどうか判定することができる
match?メソッドがtrueを返したときに「マッチした」と言う。

正規表現オブジェクト
/正規表現パターン/

match?メソッド
"文字列".match?(/正規表現パターン/)

文字列が条件と合致するか判定する
/ラテ\z/と書くと「末尾にラテが存在するか」
/\Aラテ/と書くと「先頭がラテで始まるか」となる。


その他正規表現
文字群
[]で囲むと、中の文字群のどれか1文字とマッチする。/[abc]/はaまたはbまたはcとマッチする
/[A-Za-z0-9]/と範囲指定で書くと、アルファベット大文字小文字と数字のいずれか1文字にマッチする

.
任意の1文字にマッチする。たとえば/a.c/はabcやadcなどとマッチする

*
前の文字が0回以上繰り返すときにマッチする。たとえば/ab*c/は
abcやabbbcやacにマッチする

+
前の文字が1回以上繰り返すときにマッチする。たとえば/a.+c/はabbbcやabcにマッチする。
少なくとも1回以上は繰り返さなければならないので、acにはマッチしない。

条件と合致するものを抽出する
match?メソッドとifを組み合わせると、正規表現パターンに合致するものとしないもので処理を分岐できる。


条件と合致する文字列を置換する
gsubメソッドを使うと、文字列の中で条件と合致する部分を置き換えることができる。

gsubメソッドの1つ目の引数に置換元となる文字列や正規表現を、2つ目に置換先の文字列を書く
文字列中に複数の該当箇所がある時はすべて置換する。また、破壊的にオブジェクトを変更するgsub!メソッドもある


ブロックの高度な話
ブロックを渡すメソッド呼び出し
ブロックは処理のかたまりを渡している
渡されたブロックは呼び出したメソッドの処理の中で出番がくると実行される
ブロックは一つしか渡すことができない。また、ブロックを受け取るメソッドの中には、
ブロックを渡したときと渡さないときのどちらでも動作するものがある


渡されたブロックを実行する
ブロックを渡されたかどうかをblock_given?メソッドで調べてみる
block_given?メソッドは、ブロックを渡されたかどうかを判別するメソッド
メソッドの中でblock_given?メソッドを実行すると、呼び出し時にブロックが渡されているとtrue、渡していないときはfalseを返す

渡したブロックを実行するにはyieldを使う。
yieldを実行すると、渡されたブロックを実行する


渡されたブロックを引数で受け取る
ブロックを引数で受け取って実行することもできる。
ブロックを受け取る引数は先頭に＆を書く
変数に代入されたブロックは、callメソッドで実行することができる
callメソッドは、ここではブロックの処理を実行するメソッド

